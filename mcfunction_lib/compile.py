import os
from functools import wraps
from typing import Callable

def force_dedent(string: str):

    split = string.strip("\n").split("\n")

    return "\n".join(
        [
            s.strip(" ") for s in split
        ]
    )

class MCFunctionWrapper:
    def __init__(self, func):
        self.func = func
        self.__name__ = func.__name__
        wraps(func)(self)

    def __get__(self, instance, owner):
        # Create a real callable bound function
        @wraps(self.func)
        def bound_func(*args, **kwargs):
            if instance is not None:
                return self.func(instance, *args, **kwargs)
            else:
                return self.func(*args, **kwargs)

        # Attach compile to the bound version
        bound_func.compile = self._make_compile(instance)
        return bound_func

    def _make_compile(self, instance):
        def compile_func(*, module_name, **kwargs):
            if instance is not None:
                is_global = False
                mob_name = instance.name
                call_args = (instance,)
            else:
                is_global = True
                mob_name = ""
                call_args = ()

            bodies = self.func(*call_args, module_name=module_name, **kwargs)
            if bodies is None:
                raise ValueError(f"mcfunction {self.func.__name__} does not return anything.")
            index_files = True
            if isinstance(bodies, str):
                bodies = [bodies]
                index_files = False

            for i, body in enumerate(bodies):
                body = "# autogenerated by mcfunction_lib\n\n" + force_dedent(body).strip('\n')

                mc_path = mcfunction_path(
                    module_name, self.func.__name__, mob_name, is_global,
                    f"_{i}" if index_files else "", mc_readable=False
                )
                os.makedirs(os.path.dirname(mc_path), exist_ok=True)
                with open(mc_path, 'w') as f:
                    f.write(body)

                print(f"[mcfunction_lib] Wrote: {mc_path}")

        return compile_func

    @property
    def compile(self):
        # Support calling Class.method.compile(...) too
        return self._make_compile(instance=None)


def mcfunction(func):
    return MCFunctionWrapper(func)


def mcfunction_path(module_name, func_name, mob_name="", is_global=False, suffix="", mc_readable=True):
    if mc_readable:
        if is_global:
            return f"ai:ai_modules/{module_name}/{func_name}{suffix}"
        return f"ai:ai_modules/{module_name}/{mob_name}/{func_name}{suffix}"
    else:
        if is_global:
            return f"data/datapack_modules/{module_name}/{func_name}{suffix}.mcfunction"
        return f"data/datapack_modules/{module_name}/{mob_name}/{func_name}{suffix}.mcfunction"

def compile(
    obj,
    *,
    module_name: str,
    **kwargs
):
    name = obj.__class__.__name__ if not hasattr(obj, "name") else obj.name
    print(f"[mcfunction_lib] Compiling: {obj.name}")
    for attr_name in dir(obj):
        attr = getattr(obj, attr_name)

        # Filter for callables that have a .compile attribute
        if callable(attr) and hasattr(attr, "compile"):
            attr.compile(module_name=module_name, **kwargs)


if __name__ == '__main__':


    @mcfunction
    def test(**kwargs):
        return """
        say Hello World
        """

    test.compile(
        module_name="test"
    )

    class Bob:

        def __init__(self):
            self.name = "bob"

        @mcfunction
        def grab(self, **kwargs):
            return "say grab"

        @mcfunction
        def grabtoo(self, module_name, **kwargs):
            return f"say grab2 {module_name}"

    bob = Bob()
    compile(bob, module_name="test")
